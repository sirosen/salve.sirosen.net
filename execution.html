---
layout: default
---

<h1>
    <a name="salve-is-compiled" class="anchor" href="#salve-is-compiled">
        <span class="octicon octicon-link"></span>
    </a>
    SALVE is Compiled
</h1>

<p>SALVE may look and feel to you like an interpreted language because its
expressions are so restricted and simple.
When describing actions on files and directories, it's hard to see what the
benefit of using a compiled language could be.
But all of the power of SALVE -- the benefit it provides over a sequence of
<code>cp</code>s and <code>mkdir</code>s -- is derived from the fact that it is
compiled.</p>

<p>Every execution of a SALVE manifest can be broken apart into the following
phases:</p>
<ol>
<li>Parsing and Expansion</li>
<li>Compilation</li>
<li>Verification</li>
<li>Execution</li>
</ol>

<p>SALVE's compilation target for manifests is an intermediate representation of Actions.
Actions are Python objects that support Verification and Execution.</p>

<h1>
    <a name="parsing-and-expansion" class="anchor" href="#parsing-and-expansion">
        <span class="octicon octicon-link"></span>
    </a>
    Parsing and Expansion
</h1>

<p>Parsing and Expansion is the first phase during which compile-time errors can occur.
One might think of it much like the preprocessor pass in a C compiler: it
parses input into an AST, and preforms some very lightweight variable
substitutions.</p>

<p>Manifests are separated into blocks, some of which specify other manifests.
One of the main roles of the parsing phase is to expand these manifest blocks
by parsing (and recursively expanding) the specified manifest files.
As a result, parsing cannot be separated from some interpretation of manifest
blocks.</p>

<p>It is not, however, sufficient to continue to try expanding manifest blocks without interleaving other actions.
Consider the sample manifest text below:</p>

<pre><code>manifest {
    source  $HOME/Dropbox/dropbox.manifest
}</code></pre>

<p>The value of the source path, as an absolute path, cannot be known until variable expansion takes place and <code>$HOME</code> has a definite value that has been templated in place.
For this reason, environment variable substitution must take place at the same
time as parsing, so that parsing, expansion of manifest blocks, and
substitution are all part of the same initial pass.</p>

<p>There is an alternative description of Parsing and Execution as three
independent passes which run multiple times.
In this form, the Parsing pass refers purely to the reading of a single file
and the conversion of that file into an AST.
A second pass, Substitution, runs over the AST and does variable substitution,
and a third pass, Expansion, runs over the AST searching for manifests.
That third pass recurses on any manifests, starting a new round of Parsing,
Substitution, and Expansion.</p>

<h1>
    <a name="action-conversion" class="anchor" href="#action-conversion">
        <span class="octicon octicon-link"></span>
    </a>
    Compilation
</h1>

<p>Compilation is a pass over the AST in which some basic correctness checks
are run, and the AST is converted into a sequence of Actions.
The exact actions taken during compilation vary depending on the type of block
being handled, but minimally we verify that every block has a valid set of
attributes and validate the results Parsing and Expansion.</p>

<h1>
    <a name="verification-and-execution" class="anchor"
       href="#verification-and-execution">
        <span class="octicon octicon-link"></span>
    </a>
    Verification and Execution
</h1>

<p>Although the design of SALVE centers around Verification and Execution as
separate passes, the current versions do them concurrently as a simplification
to make the implementation more feasible.
As one of the major goals of the project in this state, we want to separate
Verification and Execution into two distinct passes over the sequence of
Actions.</p>

<p>Verification is the most complete part of SALVE error checking. This is the
phase in which the compiler confirms that execution of an Action will be
successful.
The goal of verification is to ensure, before any actions are performed on
your system, that every action will be successful.
However, this is a difficult problem, and for now we are satisfied to verify
each action before attempting to perform it.</p>

<p>Execution is the final, and arguably simplest, phase.
At this point, we are confident that actions can be performed without errors
-- a requirement of SALVE is that there are no changes in state that interfere
with that assumption.
All that's left to do it make the requested changes on the filesystem.</p>
