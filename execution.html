---
layout: default
---

<h1><a name="execution-model" class="anchor" href="#execution-model"><span class="octicon octicon-link"></span></a>Execution Model</h1>

<p>The execution model of SALVE is that of a just-in-time compiled language.
Every execution of a SALVE manifest can be broken apart into phases of Parsing and Expansion, Action Conversion, and Verification and Execution.</p>

<p>SALVE's compilation target for manifests is an intermediate representation of Actions.
Actions are kept in a tree structure, and executed by a preorder traversal of the tree's leaves, so they are essentially sequential (although non-sequential executions are a future possibility).
The action tree, whose internal nodes are Action Lists, consists of Python objects.</p>

<h2><a name="actions" class="anchor" href="#actions"><span class="octicon octicon-link"></span></a>Actions</h2>

<p>Actions are callable objects, meaning that each Action wraps a functions -- the objects' <code>__call__</code> attribute.
This makes Actions a kind of heavy-weight, Object Oriented implementation of closures in Python.
However, Actions have advantages over mere closures, primarily arising from their participation in a class heirarchy.
In a pure, functional context, every action would be a closure of type <code>UNIT -&gt; UNIT</code>, making them impossible to distinguish at a Type level.
This is not to say that there are no disadvantages associated with this clunky closure architecture, only that it is fairly nuanced decision.</p>

<p>Instances of Actions carry their operands as attributes, meaning that once the Action Tree is built, the source manifests have been compiled.
At this point, the Action Tree is more or less immutable, and contains the intermediate representation of the SALVE execution.</p>

<h1><a name="parsing-expansion" class="anchor" href="#parsing-expansion"><span class="octicon octicon-link"></span></a>Parsing and Expansion</h1>

<p>Because Actions are typical Python objects, kept in heap memory, it is tempting to think that SALVE is interpreted, but this is not the case.
In fact, all phases of SALVE compilation are executed across the entire manifest tree, giving the typical separation between compile-time and run-time errors.
Parsing and Expansion is the first phase during which compile-time errors can occur.</p>

<p>When a manifest is parsed, it produces a series of blocks, some of which may be manifest blocks, specifying further manifests to parse.
It is not, however, sufficient to continue to try expanding manifest blocks without interleaving other actions.
Consider the sample manifest text below:</p>

<pre><code>manifest {
    source  $HOME/Dropbox/dropbox.manifest
}</code></pre>

<p>The value of the source path, as an absolute path, cannot be known until variable expansion takes place and <code>$HOME</code> has a definite value that has been templated in place.
As a result of this requirement, the initial phase of execution consists of alternating between converting manifests to blocks and expanding the attribute values of those blocks.
During either one of these two phases, errors may be encountered, but, as they would all be errors pertaining to the correct generation of an intermediate representation, they are all compilation errors.</p>

<h1><a name="action-conversion" class="anchor" href="#action-conversion"><span class="octicon octicon-link"></span></a>Action Conversion</h1>
<h1><a name="verify-and-exec" class="anchor" href="#verify-and-exec"><span class="octicon octicon-link"></span></a>Verification and Execution</h1>
