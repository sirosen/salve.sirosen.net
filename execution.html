---
layout: default
---

<h1>
    <a name="salve-is-compiled" class="anchor" href="#salve-is-compiled">
        <span class="octicon octicon-link"></span>
    </a>
    SALVE is Compiled
</h1>

<p>SALVE may look and feel to you like an interpreted language because its
expressions are so restricted and simple.
When describing actions on files and directories, it's hard to see what the
benefit of using a compiled language could be.
But all of the power of SALVE -- the benefit it provides over a sequence of
<code>cp</code>s and <code>mkdir</code>s -- is derived from the fact that it is
compiled.</p>

<p>Every execution of a SALVE manifest can be broken apart into the following
phases:</p>
<ol>
<li>Parsing, Substitution, and Expansion</li>
<li>Compilation</li>
<li>Verification</li>
<li>Execution</li>
</ol>

<p>SALVE's compilation target for manifests is an intermediate representation of Actions.
Actions are Python objects that support Verification and Execution.</p>

<h1>
    <a name="parsing-substitution-expansion" class="anchor"
       href="#parsing-substitution-expansion">
        <span class="octicon octicon-link"></span>
    </a>
    Parsing, Substitution, and Expansion
</h1>

<p>Parsing, Substitution, and Expansion is the first phase during which compile-time errors can occur.
One might think of it much like the preprocessor pass in a C compiler: it
parses input into an AST, and preforms some very lightweight variable
substitutions.</p>

<p>It is really the first step in compilation, but we reserve the name
Compilation to refer to the transformation between one internal representation
in the compiler and another.</p>

<h2>
    <a name="parsing" class="anchor" href="#parsing">
        <span class="octicon octicon-link"></span>
    </a>
    Parsing
</h2>

<p>Manifests are separated into an AST whose nodes are called "Blocks".
A Block is the basic unit of configuration, specifying a resource to be acted
on (a file, directory, or manifest), and the action to take on that resource
(copy, create, modify, or run).
Blocks have types, which correspond to the resource types, and they have
attributes, which describe their other properties.
During the parsing phase, Blocks are created, their attributes are assigned,
and they are collected under the Block describing the manifest in which they
are defined.</p>

<h2>
    <a name="substitution" class="anchor" href="#substitution">
        <span class="octicon octicon-link"></span>
    </a>
    Substitution
</h2>

<p>Some Block attributes may contain environment variables like
<code>$HOME</code> in their values.
These attributes cannot be used until those variables are replaced with their
respective values, so the Substutition pass scans blocks for such environment
variables and templates them into place.
</p>

<p>Substitution is a single pass, so if <code>$HOME</code> has the value
<code>/homes/$USER</code>, the variable <code>$USER</code> will not be subject
to substitution.
Furthermore, not all variables are taken from the environment.
A select few are generated by SALVE itself, and may be used even though they
are not in the environment of the calling shell.</p>

<h2>
    <a name="expansion" class="anchor" href="#expansion">
        <span class="octicon octicon-link"></span>
    </a>
    Expansion
</h2>

<p>Some Blocks specify other manifests.
One of the main roles of the Parsing, Substitution, and Expansion phase is to
expand these manifest blocks by parsing (and recursively expanding) the
specified manifest files.
As a result, parsing cannot be separated from some interpretation of manifest
blocks.</p>

<p>Note, however, that those manifests may specify yet more manifest blocks.
To achieve this, Parsing triggers Substitution, Substitution triggers
Expansion, and Expansion may invoke another round of Parsing.
In this way, the entire manifest tree is walked and converted into an AST.</p>

<h1>
    <a name="action-conversion" class="anchor" href="#action-conversion">
        <span class="octicon octicon-link"></span>
    </a>
    Compilation
</h1>

<p>Compilation is a pass over the AST in which some basic correctness checks
are run, and the AST is converted into a sequence of Actions.
The exact actions taken during compilation vary depending on the type of block
being handled, but minimally we verify that every block has a valid set of
attributes and validate the results Parsing, Substitution, and Expansion.</p>

<h1>
    <a name="verification-and-execution" class="anchor"
       href="#verification-and-execution">
        <span class="octicon octicon-link"></span>
    </a>
    Verification and Execution
</h1>

<p>Although the design of SALVE centers around Verification and Execution as
separate passes, the current versions do them concurrently as a simplification
to make the implementation more feasible.
As one of the major goals of the project in this state, we want to separate
Verification and Execution into two distinct passes over the sequence of
Actions.</p>

<p>Verification is the most complete part of SALVE error checking.
This is the phase in which the compiler confirms that execution of an Action
will be successful.
The goal of verification is to ensure, before any actions are performed on
your system, that every action will be successful.
However, this is a difficult problem, and for now we are satisfied to verify
each action immediately before attempting to perform it.</p>

<p>Execution is the final, and arguably simplest, phase.
At this point, we are confident that actions can be performed without errors
-- a requirement of SALVE is that there are no changes in state that interfere
with that assumption.
All that's left to do it make the requested changes on the filesystem.</p>
