{"name":"Salve","tagline":"Simple And Local Versioning Ecosystem","body":"SALVE\r\n=====\r\n\r\nAuthors: Stephen Rosen\r\n\r\nVersion: 1.0.0\r\n\r\nWhat is SALVE?\r\n==============\r\nSALVE is a language for deploying configuration files.\r\nIt's purpose is to make it simple to keep configuration versioned in a VCS, then deploy it in a UNIX filesystem.\r\n\r\nA SALVE repository holds the full source for SALVE, any configuration files, and a set of Manifest files.\r\nManifests are lists of\r\n * Files and directories with destinations, ugo permissions, owner, and group\r\n * Other manifests, excluding the current manifest and its ancestors (i.e. no loops allowed)\r\n\r\nTypically, a SALVE repository also holds one root manifest, which lists all of the other manifests to be used.\r\n\r\nWhat Does \"SALVE\" Stand For?\r\n============================\r\nSALVE is the Simple And Local Versioning Ecosystem.\r\n\r\nSimple, because it aims to be 100% understandable.\r\nAny manifest can be reasoned about as a sequential execution of commands.\r\n\r\nLocal, because it does not involve a centralized configuration server.\r\n\r\nVersioning, because it is designed to operate on version controlled configuration.\r\n\r\nEcosystem, because it is designed to manage configuration for any purpose on your system, ranging from personalized config files (bashrc, emacs config), to system wide properties (nginx site files, init scripts).\r\n\r\nWhy SALVE?\r\n==========\r\nSALVE is designed to make your life easier, not harder, your configuration simpler, not more complicated, and to let you do it YOUR way, no matter how right or wrong your way might be.\r\nThe primary motivation is a confluence of two major factors: versioned configuration is good and configuration management systems are too complicated.\r\n\r\nThe Server-Node Architecture is Sometimes Overcomplicated\r\n---------------------------------------------------------\r\nMost configuration management software works around the notion of a configuration management server which polls and modifies nodes.\r\nThis complicates the core task of managing configuration on an individual machine with logic relating to the interaction between the server and the managed nodes.\r\n\r\nFurthermore, with Puppet, Chef, and similar tools, the capacity for node introspection makes knowing what will hppen on deployment very hard.\r\nMachines can ask questions \"Am I listed as a 'web-server'? Am I in the 'nagios-monitored' group?\" and dispatch on the answers.\r\n\r\nWith SALVE, you instead keep a version controlled directory of configuration, and manage it as you see fit.\r\nIt is recommended to do this using one of the large free git server providers like GitHub.\r\nWhen you want to deploy on a node, all you need to do to know how a deployment will run is ensure that the local repository is up-to-date.\r\nThis dramatically simplified approach is much more suitable to personal configuration, and may even be appropriate for some small-scale Ops.\r\n\r\nGoal-Oriented Systems are Hard to Understand\r\n--------------------------------------------\r\nFurthermore, almost all of the server-node based systems are \"goal oriented\".\r\nRather than listing a set of commands, they try to describe the desired state of the system, and then put it in that state.\r\nThis makes it hard to understand the flow of execution, especially in the presence of errors.\r\n\r\nBy contrast, SALVE execution is purely sequential, meaning that it should be possible to read manifests top to bottom and know what will be executed.\r\nThis should hold regardless of the machine state.\r\n\r\nOne of the main advantages of goal-oriented configuration is that it guarantees that multiple runs are idempotent.\r\nSALVE aims to solve this problem in the simplest and most direct way possible, by using a DSL which only supports descriptions of idempotent actions.\r\n\r\nSimplicity is Elegance\r\n----------------------\r\nThe core philosophy is not disimilar to the common UNIX perspective on command line tools.\r\nRather than a few large, complicated tools that do everything, UNIX is built out of a large set of specialized tools that do their jobs well.\r\nSo too with SALVE, we have a tool that is not designed to fully satisfy every use case.\r\nInstead, it is designed to solve a single problem well, and therefore to be possible to integrate with other tools.\r\n\r\nOne of the central design principles of this project is that an elegant system is a simple system.\r\nThe configuration language is extremely limited in its syntax, but does not encode very much of its semantics in the grammar.\r\nBecause the semantics are derived almost entirely from the choice of keywords, SALVE can be extended to support new uses almost trivially.\r\n\r\nMinimal Dependencies and Assumptions\r\n====================================\r\n\r\nAlthough Windows is not presently a target, the design is portable, and could be made to work with some, admittedly significant, effort.\r\n\r\nSALVE Only Depends on What the Manifests Use\r\n--------------------------------------------\r\nSALVE does not rely on external tools like Debian's dpkg or OSX's MacPorts.\r\nUltimately, all that's required is python2.7+, a working shell, and permissions to perform the operations requested in the Manifests.\r\nAt present, these actions are restricted to those that are predefined, as we do not yet support arbitrary shell commands.\r\n\r\nSALVE does not use any python eggs or other packages, and attempts to depend more on python's extensive set of builtins than shell commands.\r\nFor example, hashing is done with python's hashlib, rather than sha512sum, md5sum, and so forth.\r\n\r\nSALVE Tries to Keep Your Safe\r\n-----------------------------\r\nSALVE does not assume that you can actually perform all of the actions you requested.\r\nThe system may have broken permissions for some directories, or you may have made mistakes in your specification of manifests.\r\nAlthough SALVE is, technically, an interpreted language, the parser, variable expansion, and safety checks prior to execution attempt to be thorough in preventing calamities.\r\n\r\nThe ultimate goal is to ensure, as much as possible, that the requested actions can be executed successfully.\r\nThis includes validating acceptable values, and ensuring the effective UID grants sufficient permissions to perform actions.\r\nUltimately, the burden is on you to ensure that your configuration is correct, but SALVE will do its best to detect and abort on errors pertaining to botched specifications prior to any part of the execution beginning.\r\n\r\nThe SALVE Language\r\n==================\r\nWhat does a SALVE manifest actually look like?\r\nHere we describe the basic format of a manifest file.\r\n\r\nExample Manifest\r\n----------------\r\nWe begin with an example, which will be broken down and explained in the sections below.\r\n\r\n```\r\nfile {\r\n    source  files/bash/bashrc\r\n    target  $HOME/.bashrc\r\n    mode    600\r\n}\r\n\r\ndirectory {\r\n    source  dirs/dircolors\r\n    target  $HOME/dircolors\r\n    action  copy\r\n}\r\n\r\nfile {\r\n    source  /etc/passwd\r\n    target  /opt/myprog/passwd-clone\r\n    mode    0440\r\n    user    admin\r\n    group   root\r\n}\r\n\r\nmanifest {\r\n    source  manifests/vim.manifest\r\n}\r\n```\r\n\r\n\r\nThe Grammar\r\n-----------\r\n\r\nA manifest is a file containing expressions, _e,_ in the following basic grammar.\r\nSome liberties have been taken with notation below.\r\n```\r\ne := Empty String\r\n   | block_id { attrs } e\r\n\r\nblock_id := \"file\"\r\n          | \"directory\"\r\n          | \"manifest\"\r\n\r\nattrs := Empty String\r\n       | name value attrs\r\n\r\nname := namechar name\r\n      | namechar\r\n\r\nnamechar := alpha\r\n          | digit\r\n          | \"_\"\r\n\r\nvalue := valuechar value\r\n       | valuechar\r\n       | '\"' quotedvalue '\"'\r\n       | \"'\" quotedvalue \"'\"\r\n\r\nquotedvalue := quotedchar quotedvalue\r\n             | quotedchar\r\n\r\nquotedchar := valuechar | \" \"\r\n\r\nvaluechar := namechar\r\n           | \"_\" | \"-\" | \"+\"\r\n           | \"=\" | \"^\" | \"&\"\r\n           | \"@\" | \"`\" | \"/\"\r\n           | \"|\" | \"~\" | \"$\"\r\n           | \"(\" | \")\" | \"[\"\r\n           | \"]\" | \".\" | \",\"\r\n           | \"<\" | \">\" | \"*\"\r\n           | \"?\" | \"!\" | \"%\"\r\n           | \"#\"\r\n```\r\n\r\nNote that this only defines the grammar of acceptable SALVE expressions\r\nfor the parser.\r\nThere are further constraints upon what keywords are valid and carry\r\nmeaning.\r\nThose are defined below.\r\n\r\nVariables\r\n---------\r\n\r\nSALVE supports the use of environment variables in templates.\r\nThese values will be pulled out of the executing shell's environment, and used to expand the attribute values of blocks in manifests.\r\n\r\nThere are a small number of exceptions to this.\r\n\r\n```SUDO_USER``` is inspected, and if set, used in place of ```USER```.\r\nAt present, there is no way to specify the real value of ```USER```, regardless of 'sudo' invocation, but this is in progress.\r\n\r\n```SALVE_ROOT``` always refers to the root directory of the SALVE repo.\r\n\r\n```SALVE_USER_PRIMARY_GROUP``` always refers to the primary group of ```USER```, after ```SUDO_USER``` substitution.\r\n\r\n```HOME``` always refers to the home directory of ```USER``` after ```SUDO_USER``` substitution.\r\nThis ensures that ```HOME``` always refers to the invoking user's homedir, even if sudo is set to reset the ```HOME``` environment variable.\r\n\r\n### Example ###\r\nGiven the block below\r\n```\r\nfile {\r\n    source  files/bash/bashrc\r\n    target  $HOME/.bashrc\r\n    mode    600\r\n}\r\n```\r\nWhen SALVE is invoked by a user, \"user1\", with home directory \"/home/user1\",\r\nthe value of \"target\" after expansion is \"/home/user1/.bashrc\"\r\nThis holds even when \"user1\" invokes SALVE with sudo.\r\n\r\nRelative Paths\r\n--------------\r\n\r\nRelative paths are also supported, so that it is not necessary to rely on values like ```$SALVE_ROOT``` and ```$PWD```.\r\nRelative paths are always interpreted relative to the root manifest's location.\r\nOne item on the docket is to make this an available override behavior via the fileroot commandline option, but to specify relative paths with respect to the dirname of the manifest that contains the block in question.\r\n\r\n### Example ###\r\nGiven the block below\r\n```\r\nfile {\r\n    source  files/bash/bashrc\r\n    target  $HOME/.bashrc\r\n    mode    600\r\n}\r\n```\r\nif SALVE is invoked as ```python salve.py -m /tmp/myconf/root.manifest```,\r\nthen the value of \"source\" after expansion is \"/tmp/myconf/files/bash/bashrc\"\r\n\r\nDefinitions\r\n-----------\r\n\r\nEach attribute of a block has a specific meaning, and many of the values themselves are keywords referring to specific actions.\r\nKnowing these meanings is key to reading and understanding a manifest.\r\nBelow are the definitions of each manifest action, given in a subscript notation.\r\nFor example, ```file[action]``` specifies the 'action' attribute of 'file' blocks.\r\n\r\n### file[action] ###\r\n\r\n> 'file[action]=copy' -- The copy action copies 'file[source]' to 'file[target]'\r\n\r\n> 'file[action]=create' -- The create action touches 'file[target]'\r\n\r\n### file[mode] ###\r\n\r\n> 'file[mode]' -- This is the umask for UGO permissions on the created file\r\n\r\n### file[user], file[group] ###\r\n\r\n> 'file[user]' -- The owner of the created file\r\n\r\n> 'file[group]' -- The owning group of the created file\r\nNote that these attributes are ignored when salve is not run as root, since chowns cannot necessarily be applied.\r\n\r\n### file[source], file[target] ###\r\n\r\n> 'file[source]' -- The path to the file to be used, typically versioned in the configuration repo\r\n\r\n> 'file[target]' -- The path to the file to which an action will be applied, or which will be created or destroyed\r\n\r\n### file[backup\\_dir], file[backup\\_log] ###\r\n\r\n> 'file[backup\\_dir]' -- The path to the directory in which file backups are stored\r\n\r\n> 'file[backup\\_log]' -- The path to the file to which backup actions are logged (date, hash, full path to file)\r\n\r\n\r\n### manifest[source] ###\r\n\r\n> 'manifest[source]' -- The path to the manifest to be expanded and executed at this location in the manifest tree\r\n\r\n\r\n### directory[action] ###\r\n\r\n> 'directory[action]=create' -- Create the directory at 'directory[target]', and any required ancestors\r\n\r\n> 'directory[action]=copy' -- Create the directory at 'directory[target]', and then recursively copy contents from 'directory[source]' to 'directory[target]'\r\n\r\n### directory[mode] ###\r\n\r\n> 'directory[mode]' -- This is the umask for UGO permissions on the created directory\r\n\r\n### directory[user], directory[group] ###\r\n\r\n> 'directory[user]' -- The owner of the created directory\r\n\r\n> 'directory[group]' -- The owning group of the created directory\r\nNote that these attributes are ignored when salve is not run as root, since chowns cannot necessarily be applied.\r\n\r\n### directory[source], directory[target] ###\r\n\r\n> 'directory[source]' -- The path to the directory to be used, typically versioned in the configuration repo\r\n\r\n> 'directory[target]' -- The path to the directory to which an action will be applied, or which will be created or destroyed\r\n\r\n### directory[backup\\_dir], directory[backup\\_log] ###\r\n\r\n> 'directory[backup\\_dir]' -- The path to the directory in which file backups are stored\r\n\r\n> 'directory[backup\\_log]' -- The path to the file to which backup actions are logged (date, hash, full path to file)\r\n\r\n\r\nSensible Defaults\r\n-----------------\r\n\r\nAs much as possible, SALVE attempts to define all behavior on underspecified blocks.\r\nThese are our set of \"sensible defaults\", specified below in the format of a manifest.\r\nA small class of values, when unspecified, result in errors.\r\nThese are generally the variables that refer to paths.\r\n\r\nThere is a special set of attributes, specified as \"common\" in the default settings, which describe values shared by all blocks unless explicitly overridden.\r\n\r\n\r\n```\r\ncommon {\r\n    backup_dir  $HOME/.salve/backups\r\n    backup_log  $HOME/.salve/backup.log\r\n    backup_log\r\n}\r\n\r\nfile {\r\n    mode    600\r\n    user    $USER\r\n    group   $SALVE_USER_PRIMARY_GROUP\r\n    action  copy\r\n}\r\n\r\ndirectory {\r\n    mode    755\r\n    user    $USER\r\n    group   $SALVE_USER_PRIMARY_GROUP\r\n    action  copy\r\n}\r\n\r\nmanifest {\r\n}\r\n```\r\n\r\nNotes\r\n=====\r\n * At present, path specifications do not support ```~```, ```*```, or any other special characters for globbing, path expansion, and so forth.\r\n * The precedence order for values is naturally Specific Block > Block Defaults > Common Attributes, but this should be more clearly documented\r\n * Current variable expansion does not support vars which expand to other vars. This should be changed.\r\n * Screwing with the directory mode can create messy problems when writing to that dir. Recommend keeping mode umask for user as 7 for now.\r\n * When overwriting a file, SALVE needs read access in order to hash it and back it up.\r\n\r\nMy Thanks for Design Input From\r\n-------------------------------\r\n * Bryce Allen\r\n * Jeremy Archer\r\n * Bryce Lanham\r\n * Minke Zhang\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}