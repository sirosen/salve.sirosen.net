---
layout: home
---

<h1>
    <a name="why-salve" class="anchor" href="#why-salve">
        <span class="octicon octicon-link"></span>
    </a>
    Why SALVE?
</h1>

<p>SALVE is designed to</p>

<ul>
    <li>Safely deploy configuration files kept in a VCS</li>
    <li>Be (much) less complicated than existing software for this purpose</li>
</ul>

<h2>
    <a name="much-safer-than-shell-scripts" class="anchor"
       href="#much-safer-than-shell-scripts">
        <span class="octicon octicon-link"></span>
    </a>
    Much Safer Than Shell Scripts
</h2>

<p>One of the typical solutions for personalized configuration is to keep a set of shell scripts which do the deployment work as file copies, directory creations, and so forth.
Why use SALVE if it offers strictly fewer features than a shell?
Because it is significantly safer to run SALVE than a shell script which may have critical typos!</p>

<p>SALVE does not assume that you can actually perform all of the actions you requested, or that you have correctly specified your manifests.
You may have typos in your files, which will be caught before any actions are run because SALVE is compiled, not interpreted.
The system may have broken permissions for some directories, or you may be trying to copy a file which doesn't exist.
The parser, variable expansion, and safety checks prior to execution attempt to be thorough in preventing calamities.</p>

<p>The ultimate goal is to ensure, as much as possible, that the requested actions can be executed successfully.
This includes validating acceptable values, and ensuring the effective UID grants sufficient permissions to perform actions.
The burden is always ultimately on you to ensure that your configuration is
correct, but your tools should make that easy, not hard.
SALVE will do its best to detect and abort on errors pertaining to botched specifications prior to any part of the execution beginning.</p>

<h2>
    <a name="chef-and-puppet-are-very-complicated" class="anchor"
       href="#chef-and-puppet-are-very-complicated">
        <span class="octicon octicon-link"></span>
    </a>
    Chef and Puppet are Very Complicated
</h2>

<p>At the time of this writing, there are a few prominent tools to manage
configuration on servers.
The most popular ones seem to be Chef and Puppet.
For those unfamiliar with these tools, the following is a list of key concepts and components in Chef:

<ul>
<li>Nodes</li>
<li>Clients</li>
<li>Environments</li>
<li>Roles</li>
<li>Run Lists</li>
<li>Attributes</li>
<li>(Encrypted) Data Bags</li>
<li>Cookbooks</li>
<li>Recipes</li>
<li>Libraries</li>
<li>(Lightweight) Resource Providers</li>
<li>Ohai</li>
<li>chef-client</li>
<li>chef-server</li>
<li>chef-solo</li>
<li>Knife</li>
<li>Ruby DSLs</li>
</ul>

There is a lot of expressive power in these tools, but there is a high cost for this power.
Chef essentially makes no distinction between a User, as someone who wants to
manage configuration, and a Developer, as someone who is prepared to contribute to
Chef.
The components are complicated and very hard to use correctly.
</p>

<p>For contrast, here is the list of SALVE's core concepts and tools:
<ul>
<li>SALVE Language</li>
<li>SALVE CLI</li>
<li>Environment Variables</li>
<li>INI Files (SALVE Configuration)</li>
</ul>
</p>

<h3>
    <a name="this-complexity-isnt-always-necessary"
        class="anchor"
        href="#this-complexity-isnt-always-necessary">
        <span class="octicon octicon-link"></span>
    </a>
    This Complexity Isn't Always Necessary
</h3>

<p>Chef, Puppet, and related tools run configuration management servers which poll and modify nodes.
This means that the management server or the client servers need to keep track of their state and know when an update needs to be made.
Furthermore, machines can ask questions "Am I listed as a 'web-server'? Am I in the 'nagios-monitored' group?" and choose different components based on the answers.
The capacity for node introspection, the implicit update processes, and the high level abstractions offered by these tools make knowing the exact state of each server and tracking down errors extremely difficult.
</p>

<p>With SALVE, you keep a version controlled directory of configuration files in the state that you want them, and write in a DSL (the SALVE Language) to deploy them.
When you want to deploy on a machine, all you need to know in order to deduce how a deployment will run is the state that the local repository is in.
This dramatically simplified approach is much more suitable to personal configuration.</p>

<h2>
    <a name="salve-is-idempotent-but-imperative" class="anchor"
       href="#salve-is-idempotent-but-imperative">
       <span class="octicon octicon-link">
       </span>
    </a>
    SALVE is Idempotent but Imperative
</h2>

<p>Many of the server-node based systems are "goal oriented".
Rather than listing a set of commands, they try to describe the desired state of the system, and then put it in that state.
This makes it hard to understand the flow of execution, especially in the presence of errors.</p>

<p>By contrast, SALVE execution is purely sequential and imperative, meaning that it should be possible to read manifests top to bottom and know what will be executed.
This should hold regardless of the machine state.</p>

<p>One of the main advantages of goal-oriented configuration is that it guarantees that multiple runs are idempotent.
SALVE aims to solve this problem in the simplest and most direct way possible, by using a DSL which only supports descriptions of idempotent actions.</p>

<h2>
    <a name="separation-of-concerns" class="anchor"
       href="#separation-of-concerns">
        <span class="octicon octicon-link"></span>
    </a>
    Separation of Concerns
</h2>

<p>The design of SALVE is not disimilar to the common UNIX perspective on command line tools.
Rather than a few large, complicated tools that do everything, UNIX is built out of a large set of specialized tools that do their jobs well.
So too with SALVE, we have a tool that is not designed to fully satisfy every use case.
Instead, it is designed to solve a single problem well, and therefore to be possible to integrate with other tools.</p>

<p>The configuration language is extremely limited in its syntax, but does not encode very much of its semantics in the grammar.
Because the semantics are derived almost entirely from the choice of keywords, SALVE can be extended to support new uses almost trivially.</p>

<h1>
    <a name="minimal-dependencies-and-assumptions" class="anchor"
       href="#minimal-dependencies-and-assumptions">
       <span class="octicon octicon-link">
       </span>
    </a>
   Minimal Dependencies and Assumptions
</h1>

<p>SALVE does not rely on external tools like Debian's dpkg or OSX's MacPorts.
Ultimately, all that's required is python2.7+, a working shell, and permissions to perform the operations requested in the Manifests.
At present, these actions are restricted to those that are predefined, as we do not yet support arbitrary shell commands.</p>

<p>SALVE does not use any python eggs or other packages, and attempts to depend more on python's extensive set of builtins than shell commands.
For example, hashing is done with python's hashlib, rather than sha512sum, md5sum, and so forth.</p>
